.. figure:: /docs/images/scipion_logo.gif
   :width: 250
   :alt: scipion logo

.. _writing-tests:

===========================
Writing Tests
===========================

Writing tests for Scipion is much like writing tests for other python code. Tests
need to be thorough, fast, isolated, consistently repeatable, and as simple as
possible. We try to have tests both for normal behaviour and for error
conditions. Tests live in the <module>/tests directory, where every file that
includes tests has a test_ prefix.

When you are adding tests to an existing test file, it is also recommended that
you study the other existing tests; it will teach you which precautions you
have to take to make your tests robust and portable.

---------------
BaseTest Class
---------------

**BaseTest** is a class that inherits from the Python’s standard library called
*unittest.TestCase* which contains tools for testing your code. Unit testing checks if all
specific parts of your function’s behavior are correct, which will make
integrating  them together with other parts much easier.

In order to write BaseTest tests, you must:

    - Write your tests as methods within classes
    - Use a series of built-in assertion methods


---------
DataSets
---------

In order to create and run Scipion tests, we provide a set of DataSets that can be
used for such purposes. They are hosted on the institution's servers and when
invoked from Scipion, they are downloaded locally to be used by the tests. Each
one is contained by volumes, set of particles, micrographs, movies, etc ...

The dataset list can be displayed with the following command:

::

    ./scipion3 testdata --list


The datasets can be downloaded using the following command:


::

    ./scipion3 testdata --download <dataset_name>

Then, the data found within the datasets folders could be used to perform the tests.

The downloaded dataset folder is locate in:

.. code-block:: bash

    $ ~/<scipion_folder>/data/tests/<dataset_name>


Another way to use the datasets that are provided by Scipion is to let the tests
themselves take responsibility for downloading them and then select the data
that will be used by the test. In that sence, Scipion provide a class named
**DataSet** which is responsible for download and handle the datasets. We will
see it with a practical example.

**Important**

    We can create new datasets just by defining a set of files that
    represent the images, stacks, micrographs, particles, movies,..., and then be
    used to create each of the tests.

------------------
Passing a test
------------------

Here’s a typical scenario for writing tests. We'll use cryosparc 2D
classification test as example which from a Set of Particles classifies them
into a set of classes

First you need to create a test file. Then import the BaseTest and DataSet
classes, define the testing class that inherits from BaseTest, and lastly, write a
series of methods to test all the cases of your function’s behavior.

BaseTest and DataSet classes are located in **pyworkflow** module. It also
contains a set of methods that are useful for managing the project generated by
Scipion.

There’s a line by line explanation below the following code:

.. code-block:: python

    from pyworkflow.tests import BaseTest, DataSet, setupTestProject

- **setupTestProject**: Method to create and setup a Project for a give Test class

Then we’ll create a class, for example TestCryosparcClassify2D, with a method
`setUpClass` which hook for setting up class fixture before running tests in
the class. This class inherits from the BaseTest class.

    Remember that every method that starts with “test” within a class that
    derives from BaseTest will be run automatically when you run a Scipion test.

.. code-block:: python

    class TestCryosparcClassify2D(BaseTest):
        @classmethod
        def setUpClass(cls):
            setupTestProject(cls)
            dataSetName = 'xmipp_tutorial'
            dataset = DataSet.getDataSet(dataSetName)
            self.partFolderPath = dataset.getFile('particles')
            self.pattern = 'BPV_*.stk'

* **DataSet.getDataSet(dataSetName)**: this method is called every time the dataset want to be retrieved

* **dataset.getFile**: method that returns the path where the files are located.

Once method setUpClass has been created, each of the tests is written.

In our example:

.. code-block:: python

    def testCryosparc2D(self):

Inside, we will create a Scipion workflow invoking and executing each
of the necessaries protocols to our test.

First we'll import a set of particles using `ProtImportParticles`
protocol in order to be classify. For that, we'll create a new protocol
instance (`newProtocol(ProtocolClass) method`) through the project and return a
newly created protocol of the given class. After that, we will proceed to
execute it and then we will check if the output has been correct.

    newProtocol method accept *kwargs* that represent the protocol parameters.

.. code-block:: python

        # Define import particles protocol
        objLabel = 'Import from file (particles)'
        protImportPart = cls.newProtocol(ProtImportParticles,
                                         objLabel=objLabel,
                                         filesPath=self.partFolderPath,
                                         filesPattern=self.pattern,
                                         samplingRate=samplingRate,
                                         importFrom=ProtImportParticles.IMPORT_FROM_FILES)

        # Lunching the import particle protocol
        cls.launchProtocol(protImportPart)
        # Check that input images have been imported
        if protImportPart.outputParticles is None:
            raise Exception('Import of images: %s, failed. '
                            'outputParticles is None.' % self.partPattern)


* **launchProtocol**: method to launch a given protocol

Once the particles have been imported, an instance of the Cryosparc 2D
classification protocol (`ProtCryo2D`) will be created which will have as input
the particles imported by the ProtImportParticles protocol.

.. code-block:: python

        # Define cryosparc 2D classification protocol
        prot2D = self.newProtocol(ProtCryo2D,
                                  doCTF=False, maskDiameterA=340,
                                  numberOfMpi=4, numberOfThreads=1)
        prot2D.inputParticles.set(protImportPart.outputParticles)
        prot2D.numberOfClasses.set(5)
        prot2D.numberOnlineEMIterator.set(40)
        prot2D.compute_use_ssd.set(False)
        prot2D.setObjLabel(label)
        self.launchProtocol(prot2D)

        # Check if 2D Classification protocol finish successfully
        self.assertIsNotNone(cryosparcProt.outputClasses,
                             "There was a problem with Cryosparc 2D classify")

        # Check if the classes has 2D alignment
        for class2D in cryosparcProt.outputClasses:
            self.assertTrue(class2D.hasAlignment2D())

As can be seen, all parameters of a protocol can be modified using the *set* method.

The following code shows the complete implementation of the test:


.. code-block:: python

    from pyworkflow.tests import BaseTest, DataSet, setupTestProject
    from pwem.protocols import ProtImportParticles

    class TestCryosparcClassify2D(BaseTest):
        @classmethod
        def setUpClass(cls):
            setupTestProject(cls)
            dataSetName = 'xmipp_tutorial'
            dataset = DataSet.getDataSet(dataSetName)
            self.partFolderPath = dataset.getFile('particles')
            self.pattern = 'BPV_*.stk'

        def testCryosparc2D(self):
            def _runCryosparcClassify2D(label=''):

                # Define import particles protocol
                objLabel = 'Import from file (particles)'
                protImportPart = cls.newProtocol(ProtImportParticles,
                                                 objLabel=objLabel,
                                                 filesPath=self.partFolderPath,
                                                 filesPattern=self.pattern,
                                                 samplingRate=samplingRate,
                                                 importFrom=ProtImportParticles.IMPORT_FROM_FILES)

                # Lunching the import particle protocol
                cls.launchProtocol(protImportPart)
                # Check that input images have been imported
                if protImportPart.outputParticles is None:
                    raise Exception('Import of images: %s, failed. '
                                    'outputParticles is None.' % self.partPattern)

                # Define cryosparc 2D classification protocol
                prot2D = self.newProtocol(ProtCryo2D,
                                          doCTF=False, maskDiameterA=340,
                                          numberOfMpi=4, numberOfThreads=1)
                prot2D.inputParticles.set(protImportPart.outputParticles)
                prot2D.numberOfClasses.set(5)
                prot2D.numberOnlineEMIterator.set(40)
                prot2D.compute_use_ssd.set(False)
                prot2D.setObjLabel(label)
                self.launchProtocol(prot2D)
                return prot2D

            def _checkAsserts(cryosparcProt):
                self.assertIsNotNone(cryosparcProt.outputClasses,
                                     "There was a problem with Cryosparc 2D classify")

                for class2D in cryosparcProt.outputClasses:
                    self.assertTrue(class2D.hasAlignment2D())

            cryosparcProtGpu = _runCryosparcClassify2D(label="Cryosparc classify2D GPU")
            _checkAsserts(cryosparcProtGpu)

Scipion discovers all tests using the following command:

::

    ./scipion3 test


for more information run:

::

    ./scipion3 test -h


example:

::

    $ ./scipion3 test --grep cryosparc

     scipion3 tests cryosparc2.tests.test_utils
       scipion3 tests cryosparc2.tests.test_utils.TestUtils
     scipion3 tests cryosparc2.tests.test_protocols_cryosparc2
       scipion3 tests cryosparc2.tests.test_protocols_cryosparc2.TestCryosparcSharppening
       scipion3 tests cryosparc2.tests.test_protocols_cryosparc2.TestCryosparcParticlesSubtract
       scipion3 tests cryosparc2.tests.test_protocols_cryosparc2.TestCryosparcNonUniformRefine3D
       scipion3 tests cryosparc2.tests.test_protocols_cryosparc2.TestCryosparcLocalRefine
       scipion3 tests cryosparc2.tests.test_protocols_cryosparc2.TestCryosparcLocalCtfRefinement
       scipion3 tests cryosparc2.tests.test_protocols_cryosparc2.TestCryosparcGlobalCtfRefinement
       scipion3 tests cryosparc2.tests.test_protocols_cryosparc2.TestCryosparcClassify2D
       scipion3 tests cryosparc2.tests.test_protocols_cryosparc2.TestCryosparc3DRefinement
       scipion3 tests cryosparc2.tests.test_protocols_cryosparc2.TestCryosparc3DInitialModel
       scipion3 tests cryosparc2.tests.test_protocols_cryosparc2.TestCryosparc3DClassification

This command shows all tests that matching with the pattern "cryosparc" with the
following order: <module_name>.<tests_folder>.<test_file>.<test_class_derived_from_BaseTest>

To execute an Scipion test just type:

::

    $ ./scipion3 tests cryosparc2.tests.test_protocols_cryosparc2.TestCryosparcClassify2D

and all the defined tests within the class TestCryosparcClassify2D will be run automatically
